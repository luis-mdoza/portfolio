const localProjects = [
  {
    slug: "lumen-health",
    title: "Lumen Health",
    year: "2025",
    type: "Application",
    tags: ["app", "service"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23d9d9d9'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ELumen 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e2e2e2'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ELumen 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23ededed'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ELumen 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Patient-first experience for chronic care tracking.",
    business: "Reduced drop-off in onboarding by 28%.",
    involvement: "Led product UX, motion prototypes, and design system updates.",
  },
  {
    slug: "atelier-commerce",
    title: "Atelier Commerce",
    year: "2024",
    type: "Website",
    tags: ["website"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e0e0e0'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtelier 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23f0f0f0'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtelier 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23dcdcdc'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtelier 03%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e8e8e8'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtelier 04%3C/text%3E%3C/svg%3E",
    ],
    summary: "Luxury commerce platform with editorial storytelling.",
    business: "Improved conversion for high-intent sessions.",
    involvement: "Defined IA, interaction language, and visual system.",
  },
  {
    slug: "flowcase",
    title: "Flowcase",
    year: "2024",
    type: "Prototype",
    tags: ["prototype", "app"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e4e4e4'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EFlowcase 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23efefef'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EFlowcase 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23dadada'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EFlowcase 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Collaboration concept for distributed product teams.",
    business: "Validated with 12 design orgs for feasibility.",
    involvement: "Designed rapid prototypes and moderated testing.",
  },
  {
    slug: "rivet-finance",
    title: "Rivet Finance",
    year: "2023",
    type: "Service",
    tags: ["service"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e3e3e3'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ERivet 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23f2f2f2'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ERivet 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23d7d7d7'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ERivet 03%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e9e9e9'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3ERivet 04%3C/text%3E%3C/svg%3E",
    ],
    summary: "Service blueprint for real-time portfolio insight.",
    business: "Shortened reporting cycle from weekly to daily.",
    involvement: "Mapped workflows and partnered with data engineering.",
  },
  {
    slug: "aurora-os",
    title: "Aurora OS",
    year: "2023",
    type: "Application",
    tags: ["app"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23dbdbdb'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAurora 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23eeeeee'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAurora 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23dcdcdc'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAurora 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Control layer for connected home devices.",
    business: "Unified product line into one cohesive platform.",
    involvement: "Owned interaction model and accessibility spec.",
  },
  {
    slug: "echo-studio",
    title: "Echo Studio",
    year: "2022",
    type: "Website",
    tags: ["website", "prototype"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e1e1e1'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EEcho 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23f0f0f0'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EEcho 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23d6d6d6'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EEcho 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Portfolio toolkit for creative studios.",
    business: "Increased inbound leads by 2x.",
    involvement: "Crafted responsive UI and launch assets.",
  },
  {
    slug: "kite-labs",
    title: "Kite Labs",
    year: "2022",
    type: "Service",
    tags: ["service", "app"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23dedede'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EKite 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23eeeeee'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EKite 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e4e4e4'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EKite 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Industrial analytics workflow for operators.",
    business: "Decreased decision time by 40%.",
    involvement: "Directed UX, field research, and UI kit.",
  },
  {
    slug: "atlas-mobility",
    title: "Atlas Mobility",
    year: "2021",
    type: "Prototype",
    tags: ["prototype"],
    images: [
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23e3e3e3'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtlas 01%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23f2f2f2'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtlas 02%3C/text%3E%3C/svg%3E",
      "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540'%3E%3Crect width='960' height='540' fill='%23d7d7d7'/%3E%3Ctext x='48' y='80' font-family='Helvetica Neue, Arial, sans-serif' font-size='28' fill='%23111111'%3EAtlas 03%3C/text%3E%3C/svg%3E",
    ],
    summary: "Mobility experience for shared electric fleets.",
    business: "Supported pilot across three metro regions.",
    involvement: "Designed concept UI and service walkthroughs.",
  },
];

const projects = window.PROJECTS || localProjects;

const grid = document.querySelector("#works-grid");
const filters = document.querySelectorAll(".filter");
const filtersWrap = document.querySelector(".filters");
const filterToggle = document.querySelector(".filter-toggle");
const viewButtons = document.querySelectorAll(".view-toggle__btn");
const intro = document.querySelector(".intro");
const cursor = document.querySelector(".custom-cursor");
const translations = {
  en: {
    role: "Product Designer",
    nav_work: "Work",
    nav_about: "About",
    nav_contact: "Contact",
    nav_resume: "Resume",
    hero_title: "Works",
    hero_subtitle: "Interaction-focused products, systems, and prototypes.",
    filter_all: "All",
    filter_app: "#Application",
    filter_website: "#Website",
    filter_service: "#Service",
    filter_prototype: "#Prototype",
    view_grid: "Grid",
    view_list: "List",
    about_title: "About",
    about_body:
      "I design product experiences across mobile, web, and embedded platforms. I focus on systems thinking, motion, and tight collaboration with engineering teams.",
    footer_line: "Let’s work together.",
  },
  ja: {
    role: "プロダクトデザイナー",
    nav_work: "作品",
    nav_about: "紹介",
    nav_contact: "連絡",
    nav_resume: "履歴書",
    hero_title: "作品",
    hero_subtitle: "プロダクトと体験のためのデザイン。",
    filter_all: "すべて",
    filter_app: "#アプリケーション",
    filter_website: "#ウェブサイト",
    filter_service: "#サービス",
    filter_prototype: "#プロトタイプ",
    view_grid: "グリッド",
    view_list: "リスト",
    about_title: "紹介",
    about_body:
      "モバイル、ウェブ、組み込みのプロダクト体験を設計しています。システム思考、モーション、エンジニアリングとの連携を重視します。",
    footer_line: "一緒に仕事をしましょう。",
  },
  es: {
    role: "Diseñador de Producto",
    nav_work: "Trabajo",
    nav_about: "Acerca de",
    nav_contact: "Contacto",
    nav_resume: "Currículum",
    hero_title: "Trabajos",
    hero_subtitle: "Productos, sistemas y prototipos enfocados en interacción.",
    filter_all: "Todo",
    filter_app: "#Aplicación",
    filter_website: "#Sitio web",
    filter_service: "#Servicio",
    filter_prototype: "#Prototipo",
    view_grid: "Cuadrícula",
    view_list: "Lista",
    about_title: "Acerca de",
    about_body:
      "Diseño experiencias de producto en móvil, web y sistemas embebidos. Me enfoco en pensamiento sistémico, motion y colaboración con ingeniería.",
    footer_line: "Trabajemos juntos.",
  },
};

let currentLang = "en";

const prefersReducedMotion = window.matchMedia(
  "(prefers-reduced-motion: reduce)"
).matches;

const charset = "01";
const loopHandles = new WeakMap();
const hoverTimeouts = new WeakMap();

const imageLoadCache = new Map();
const preloadImage = (src) => {
  if (!src || imageLoadCache.has(src)) return;
  const img = new Image();
  img.onload = () => imageLoadCache.set(src, true);
  img.onerror = () => imageLoadCache.set(src, false);
  img.src = src;
};

const getLoadedImages = (sources) =>
  sources.filter((src) => imageLoadCache.get(src) === true);

const supportsWebGL = () => {
  try {
    const canvas = document.createElement("canvas");
    return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
  } catch {
    return false;
  }
};

const WEBGL_DEBUG = true;
let activeWebGLHover = null;

const randomizeText = (text) =>
  text
    .split("")
    .map((char) =>
      char === " " ? " " : charset[Math.floor(Math.random() * charset.length)]
    )
    .join("");

const easeInOut = (t) =>
  t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

const scrambleToText = (
  element,
  finalText,
  { duration = 600, interval = 12 } = {}
) => {
  if (!element || prefersReducedMotion) {
    if (element) element.textContent = finalText;
    return;
  }

  const total = finalText.length;
  const startTime = Date.now();
  const timer = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = easeInOut(progress);
    const revealCount = Math.floor(eased * total);
    const output = finalText
      .split("")
      .map((char, index) => {
        if (char === " ") return " ";
        if (index < revealCount) return char;
        return charset[Math.floor(Math.random() * charset.length)];
      })
      .join("");

    element.textContent = output;
    if (progress >= 1) {
      clearInterval(timer);
      element.textContent = finalText;
    }
  }, interval);
};

const startScrambleLoop = (element, duration = 1200) => {
  if (!element || prefersReducedMotion) return;
  const original = element.dataset.original || element.textContent;
  element.dataset.original = original;
  stopScrambleLoop(element);
  const timer = setInterval(() => {
    element.textContent = randomizeText(original);
  }, 30);
  loopHandles.set(element, timer);
  const timeout = setTimeout(() => {
    stopScrambleLoop(element);
    scrambleToText(element, original, { duration: 500 });
  }, duration);
  hoverTimeouts.set(element, timeout);
};

const stopScrambleLoop = (element) => {
  const timer = loopHandles.get(element);
  if (timer) clearInterval(timer);
  loopHandles.delete(element);
  const timeout = hoverTimeouts.get(element);
  if (timeout) clearTimeout(timeout);
  hoverTimeouts.delete(element);
};

const createPlaceholder = (title) => {
  const text = title.replace(/[^a-z0-9 ]/gi, "");
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="960" height="540">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stop-color="#d9d9d9"/>
          <stop offset="100%" stop-color="#f2f2f0"/>
        </linearGradient>
      </defs>
      <rect width="960" height="540" fill="url(#g)"/>
      <text x="48" y="80" font-family="Helvetica Neue, Arial, sans-serif" font-size="28" fill="#111111" letter-spacing="2">
        ${text.toUpperCase()}
      </text>
    </svg>
  `.trim();
  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
};

let listPreviewEl = null;
let listPreviewImg = null;
let listPreviewTimer = null;
let listPreviewIndex = 0;
let listPreviewSources = [];
let listPreviewAnim = null;
let listPreviewPos = { x: 0, y: 0 };
let listPreviewTarget = { x: 0, y: 0 };

const prefetchedLinks = new Set();
let footerStatusTimer = null;

const prefetchLink = (href) => {
  if (!href || prefetchedLinks.has(href)) return;
  if (window.location.protocol === "file:") return;
  const link = document.createElement("link");
  link.rel = "prefetch";
  link.as = "document";
  link.href = href;
  document.head.appendChild(link);
  prefetchedLinks.add(href);
};

const setupPageTransitions = () => {
  document.addEventListener("click", (event) => {
    if (document.body.classList.contains("is-intro")) return;
    if (event.defaultPrevented || event.button !== 0) return;
    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
    const link = event.target.closest("a");
    if (!link) return;
    const href = link.getAttribute("href");
    if (!href || href.startsWith("#")) return;
    if (link.target === "_blank" || link.hasAttribute("download")) return;
    if (href.startsWith("mailto:") || href.startsWith("tel:")) return;
    let url;
    try {
      url = new URL(href, window.location.href);
    } catch {
      return;
    }
    if (url.origin !== window.location.origin) return;
    if (url.pathname === window.location.pathname && url.hash) return;
    event.preventDefault();
    document.body.classList.add("is-navigating");
    setTimeout(() => {
      window.location.href = url.href;
    }, 150);
  });
};

const ensureListPreview = () => {
  if (listPreviewEl) return;
  listPreviewEl = document.createElement("div");
  listPreviewEl.className = "list-hover-preview";
  listPreviewImg = document.createElement("img");
  listPreviewImg.alt = "";
  listPreviewImg.setAttribute("aria-hidden", "true");
  listPreviewEl.appendChild(listPreviewImg);
  document.body.appendChild(listPreviewEl);
};

const startListPreviewLoop = (sources, title) => {
  ensureListPreview();
  listPreviewSources = sources.length ? sources : [createPlaceholder(title)];
  listPreviewIndex = 0;
  listPreviewImg.src = listPreviewSources[listPreviewIndex];
  if (listPreviewTimer) window.clearInterval(listPreviewTimer);
  listPreviewTimer = window.setInterval(() => {
    listPreviewIndex = (listPreviewIndex + 1) % listPreviewSources.length;
    listPreviewImg.src = listPreviewSources[listPreviewIndex];
  }, 180);
};

const stopListPreviewLoop = () => {
  if (listPreviewTimer) window.clearInterval(listPreviewTimer);
  listPreviewTimer = null;
};

const positionListPreview = (event) => {
  if (!listPreviewEl) return;
  const offsetX = 28;
  const offsetY = 28;
  const width = listPreviewEl.offsetWidth || 240;
  const height = listPreviewEl.offsetHeight || 135;
  const maxX = window.innerWidth - width - 12;
  const maxY = window.innerHeight - height - 12;
  const nextX = Math.min(event.clientX + offsetX, maxX);
  const nextY = Math.max(12, Math.min(event.clientY - height - offsetY, maxY));
  listPreviewTarget.x = nextX;
  listPreviewTarget.y = nextY;
};

const hideListPreview = () => {
  if (!listPreviewEl) return;
  listPreviewEl.classList.remove("is-visible");
  stopListPreviewLoop();
  if (listPreviewAnim) {
    cancelAnimationFrame(listPreviewAnim);
    listPreviewAnim = null;
  }
};

const setupListHoverPreview = (card, project) => {
  const title = card.querySelector(".work-card__title");
  if (!title) return;
  const sources =
    project.images?.length
      ? project.images
      : [project.image || createPlaceholder(project.title)];

  const handleEnter = (event) => {
    if (!grid.classList.contains("is-list")) return;
    startListPreviewLoop(sources, project.title);
    positionListPreview(event);
    if (!listPreviewAnim) {
      listPreviewPos.x = listPreviewTarget.x;
      listPreviewPos.y = listPreviewTarget.y;
      const animate = () => {
        const dx = listPreviewTarget.x - listPreviewPos.x;
        const dy = listPreviewTarget.y - listPreviewPos.y;
        listPreviewPos.x += dx * 0.12;
        listPreviewPos.y += dy * 0.12;
        listPreviewEl.style.transform = `translate3d(${listPreviewPos.x}px, ${listPreviewPos.y}px, 0)`;
        listPreviewAnim = requestAnimationFrame(animate);
      };
      listPreviewAnim = requestAnimationFrame(animate);
    }
    listPreviewEl.classList.add("is-visible");
  };

  const handleMove = (event) => {
    if (!grid.classList.contains("is-list")) return;
    positionListPreview(event);
  };

  const handleLeave = () => {
    hideListPreview();
  };

  title.addEventListener("mouseenter", handleEnter);
  title.addEventListener("mousemove", handleMove);
  title.addEventListener("mouseleave", handleLeave);
};

const setupTitleParallax = (card) => {
  const title = card.querySelector(".work-card__title");
  if (!title) return;
  let raf = null;
  let posX = 0;
  let posY = 0;
  let targetX = 0;
  let targetY = 0;
  const maxOffset = 8;

  const animate = () => {
    posX += (targetX - posX) * 0.18;
    posY += (targetY - posY) * 0.18;
    title.style.setProperty("--parallax-x", `${posX.toFixed(2)}px`);
    title.style.setProperty("--parallax-y", `${posY.toFixed(2)}px`);
    raf = requestAnimationFrame(animate);
  };

  const handleMove = (event) => {
    if (!grid.classList.contains("is-list")) return;
    const rect = title.getBoundingClientRect();
    const relX = (event.clientX - rect.left) / rect.width - 0.5;
    const relY = (event.clientY - rect.top) / rect.height - 0.5;
    targetX = relX * maxOffset * 2;
    targetY = relY * maxOffset;
    if (!raf) raf = requestAnimationFrame(animate);
  };

  const handleLeave = () => {
    targetX = 0;
    targetY = 0;
    if (!raf) raf = requestAnimationFrame(animate);
    setTimeout(() => {
      if (Math.abs(posX) < 0.2 && Math.abs(posY) < 0.2 && raf) {
        cancelAnimationFrame(raf);
        raf = null;
        title.style.removeProperty("--parallax-x");
        title.style.removeProperty("--parallax-y");
      }
    }, 200);
  };

  title.addEventListener("mousemove", handleMove);
  title.addEventListener("mouseleave", handleLeave);
};

const renderProjects = (filter) => {
  grid.innerHTML = "";
  const filtered = projects.filter((project) =>
    filter === "all" ? true : project.tags.includes(filter)
  );

  filtered.forEach((project, index) => {
    const imageSource =
      project.thumbnail ||
      project.image ||
      project.images?.[0] ||
      createPlaceholder(project.title);
    const card = document.createElement("a");
    card.className = "work-card";
    const slug = project.slug || project.title.toLowerCase().replace(/\s+/g, "-");
    card.href = `project.html?project=${encodeURIComponent(slug)}`;
    const jitter = Math.floor(Math.random() * 200);
    card.style.transitionDelay = `${index * 60}ms`;
    card.style.animationDelay = `${jitter}ms`;
    card.innerHTML = `
      <div class="work-card__media">
        <img src="${imageSource}" alt="${project.title}" loading="lazy" />
      </div>
      <div class="work-card__meta">
        <span data-scramble>${project.year}</span>
        <span data-scramble data-auto-translate="true">${project.type}</span>
      </div>
      <div class="work-card__title" data-scramble data-auto-translate="true">
        ${project.title}
      </div>
      <div class="work-card__tags" data-scramble data-auto-translate="true">
        ${project.tags.map((tag) => `#${tag}`).join(" ")}
      </div>
    `;
    grid.appendChild(card);
    setupCardScramble(card);
    setupHoverImages(card, project);
    (project.images || []).forEach(preloadImage);
    setupListHoverPreview(card, project);
    setupTitleParallax(card);
    card.addEventListener("mouseenter", () => prefetchLink(card.href));
    requestAnimationFrame(() => {
      if (!document.body.classList.contains("is-intro")) {
        card.classList.add("is-visible");
      }
    });
  });

};

const triggerGridDrop = () => {
  const cards = document.querySelectorAll(".work-card");
  const rootStyles = window.getComputedStyle(document.documentElement);
  const durationValue = rootStyles.getPropertyValue("--drop-duration").trim();
  const durationMs = durationValue.endsWith("ms")
    ? parseFloat(durationValue)
    : parseFloat(durationValue) * 1000;
  const useSimpleFade = document.documentElement.classList.contains("is-safari");
  cards.forEach((card, index) => {
    const jitter = Math.floor(Math.random() * 240);
    card.classList.remove("is-visible");
    if (useSimpleFade) {
      card.classList.remove("drop-in");
      card.style.animationDelay = "";
      setTimeout(() => {
        card.classList.add("is-visible");
      }, jitter + index * 60);
    } else {
      card.classList.add("drop-in");
      card.style.animationDelay = `${jitter + index * 40}ms`;
      const finalize = () => {
        card.classList.remove("drop-in");
        card.classList.add("is-visible");
      };
      card.addEventListener("animationend", finalize, { once: true });
      setTimeout(finalize, durationMs + jitter + index * 40 + 80);
    }
  });

  const aboutSection = document.querySelector(".about");
  const lastDelay = cards.length
    ? (useSimpleFade ? 0 : durationMs) + Math.max(0, (cards.length - 1) * 40) + 240
    : useSimpleFade ? 0 : durationMs;
  if (aboutSection) {
    aboutSection.classList.remove("is-visible");
    setTimeout(() => {
      aboutSection.classList.add("is-visible");
    }, lastDelay + 200);
  }
};

const setupCardScramble = (card) => {
  const elements = card.querySelectorAll("[data-scramble]");
  elements.forEach((element) => {
    element.dataset.original = element.textContent;
    if (!prefersReducedMotion) {
      scrambleToText(element, element.dataset.original, { duration: 650 });
    }
  });

  card.addEventListener("mouseenter", () => {
    elements.forEach((element) => startScrambleLoop(element, 1200));
  });

  card.addEventListener("mouseleave", () => {
    elements.forEach((element) => {
      stopScrambleLoop(element);
      scrambleToText(element, element.dataset.original, { duration: 400 });
    });
  });
};

const setupHoverImages = (card, project) => {
  const images = project.images || [];
  if (!images.length) return;
  const mediaWrap = card.querySelector(".work-card__media");
  const img = mediaWrap?.querySelector("img");
  if (!mediaWrap || !img) return;
  const original = img.src;

  let timer = null;
  let controller = null;
  let fadeTimeout = null;
  const shuffle = (list) =>
    list
      .map((item) => ({ item, sort: Math.random() }))
      .sort((a, b) => a.sort - b.sort)
      .map(({ item }) => item);

  const start = () => {
    if (fadeTimeout) {
      clearTimeout(fadeTimeout);
      fadeTimeout = null;
    }
    img.classList.remove("is-fading");
    preloadImage(original);
    images.forEach(preloadImage);
    const hoverSources = [original, ...images].filter(Boolean);
    if (supportsWebGL() && hoverSources.length > 1) {
      if (activeWebGLHover && activeWebGLHover !== controller) {
        activeWebGLHover.stop(true);
      }
      if (controller) {
        controller.stop(true);
        controller = null;
      }
      controller = createWebGLHover(mediaWrap, hoverSources, original);
      if (controller) {
        activeWebGLHover = controller;
        controller.start();
        return;
      }
    }
    const sequence = shuffle(hoverSources);
    if (sequence.length < 2) return;
    let index = 0;
    clearInterval(timer);
    timer = window.setInterval(() => {
      img.src = sequence[index % sequence.length];
      index += 1;
    }, 180);
  };

  const stop = () => {
    clearInterval(timer);
    timer = null;
    const currentController = controller;
    if (currentController) {
      currentController.stop(false);
      controller = null;
      if (activeWebGLHover === currentController) {
        activeWebGLHover = null;
      }
      return;
    }
    img.classList.add("is-fading");
    if (fadeTimeout) clearTimeout(fadeTimeout);
    fadeTimeout = window.setTimeout(() => {
      img.src = original;
      requestAnimationFrame(() => {
        img.classList.remove("is-fading");
      });
      fadeTimeout = null;
    }, 200);
  };

  card.addEventListener("pointerenter", start);
  card.addEventListener("pointerleave", stop);
};

const createWebGLHover = (mediaWrap, sources, fallbackSrc) => {
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl", { premultipliedAlpha: false });
  if (!gl) return null;
  if (WEBGL_DEBUG) {
    console.log("[webgl] init", { sources });
  }

  const vertexSrc = `
    attribute vec2 a_position;
    attribute vec2 a_uv;
    varying vec2 v_uv;
    void main() {
      v_uv = a_uv;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentSrc = `
    precision mediump float;
    varying vec2 v_uv;
    uniform sampler2D u_tex0;
    uniform sampler2D u_tex1;
    uniform float u_progress;

    float hash(vec2 p) {
      return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
    }

    float hnoise(vec2 x) {
      vec2 i = floor(x);
      vec2 f = fract(x);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }

    void main() {
      vec2 uv = vec2(v_uv.x, 1.0 - v_uv.y);
      float prog = smoothstep(0.0, 1.0, u_progress);
      float hn = hnoise(uv * 10.0);
      vec2 dir = normalize(vec2(0.5) - uv);
      vec2 d = vec2(0.0, dir.y);
      vec2 uv1 = uv + d * prog / 5.0 * (1.0 + hn * 0.5);
      vec2 uv2 = uv - d * (1.0 - prog) / 5.0 * (1.0 + hn * 0.5);
      vec4 t1 = texture2D(u_tex0, uv1);
      vec4 t2 = texture2D(u_tex1, uv2);
      gl_FragColor = mix(t1, t2, prog);
    }
  `;

  const createShader = (type, source) => {
    const shader = gl.createShader(type);
    if (!shader) return null;
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };

  const vertexShader = createShader(gl.VERTEX_SHADER, vertexSrc);
  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSrc);
  if (!vertexShader || !fragmentShader) return null;

  const program = gl.createProgram();
  if (!program) return null;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (WEBGL_DEBUG) {
      console.warn("[webgl] link failed", gl.getProgramInfoLog(program));
    }
    return null;
  }
  gl.useProgram(program);

  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  const vertices = new Float32Array([
    -1, -1, 0, 0,
    1, -1, 1, 0,
    -1, 1, 0, 1,
    -1, 1, 0, 1,
    1, -1, 1, 0,
    1, 1, 1, 1,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  const aPosition = gl.getAttribLocation(program, "a_position");
  const aUv = gl.getAttribLocation(program, "a_uv");
  gl.enableVertexAttribArray(aPosition);
  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(aUv);
  gl.vertexAttribPointer(aUv, 2, gl.FLOAT, false, 16, 8);

  const uTex0 = gl.getUniformLocation(program, "u_tex0");
  const uTex1 = gl.getUniformLocation(program, "u_tex1");
  const uProgress = gl.getUniformLocation(program, "u_progress");

  const createTexture = () => {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
  };

  const tex0 = createTexture();
  const tex1 = createTexture();

  const loadImage = (src) =>
    new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = reject;
      const resolved = new URL(src, window.location.href).href;
      img.src = resolved;
    });

  const imageCache = new Map();
  const getImage = async (src) => {
    if (imageCache.has(src)) return imageCache.get(src);
    const img = await loadImage(src);
    imageCache.set(src, img);
    return img;
  };

  let currentIndex = 0;
  let timer = null;
  let animating = false;
  let isStopping = false;
  let resizeObserver = null;
  let isActive = false;

  const setSize = () => {
    const rect = mediaWrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
  };

  const render = (progress) => {
    gl.useProgram(program);
    gl.uniform1f(uProgress, progress);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex0);
    gl.uniform1i(uTex0, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, tex1);
    gl.uniform1i(uTex1, 1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  };

  const transitionTo = async (nextIndex, force = false, reverse = false) => {
    if (animating && !force) return;
    animating = true;
    const currentSrc = sources[currentIndex] || fallbackSrc;
    const nextSrc = sources[nextIndex] || fallbackSrc;
    try {
      const [img0, img1] = await Promise.all([getImage(currentSrc), getImage(nextSrc)]);
      gl.bindTexture(gl.TEXTURE_2D, tex0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img0);
      gl.bindTexture(gl.TEXTURE_2D, tex1);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img1);
    } catch {
      if (WEBGL_DEBUG) {
        console.warn("[webgl] image load failed", { currentSrc, nextSrc });
      }
      animating = false;
      stop();
      return;
    }

    const start = performance.now();
    const duration = 1100;
    const step = (now) => {
      const t = Math.min((now - start) / duration, 1);
      render(reverse ? 1 - t : t);
      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        currentIndex = nextIndex;
        animating = false;
      }
    };
    requestAnimationFrame(step);
  };

  const start = async () => {
    if (isActive || isStopping) return;
    isActive = true;
    isStopping = false;
    mediaWrap.classList.add("is-webgl");
    mediaWrap.appendChild(canvas);
    setSize();
    resizeObserver = new ResizeObserver(setSize);
    resizeObserver.observe(mediaWrap);
    if (WEBGL_DEBUG) {
      canvas.style.outline = "1px solid rgba(0, 0, 0, 0.25)";
    }
    if (WEBGL_DEBUG) {
      console.log("[webgl] start");
    }
    if (sources.length > 1 && sources[0] === fallbackSrc) {
      currentIndex = 0;
      await transitionTo(1);
    } else {
      await transitionTo(0);
    }
    timer = window.setInterval(() => {
      const nextIndex = (currentIndex + 1) % sources.length;
      transitionTo(nextIndex);
    }, 1500);
  };

  const stop = async (lose = false) => {
    if (isStopping) return;
    isStopping = true;
    isActive = false;
    clearInterval(timer);
    timer = null;
    if (currentIndex !== 0) {
      await transitionTo(0, true, true);
    }
    mediaWrap.classList.remove("is-webgl");
    if (canvas.parentElement) canvas.remove();
    if (resizeObserver) resizeObserver.disconnect();
    currentIndex = 0;
    animating = false;
    if (lose) {
      gl.getExtension("WEBGL_lose_context")?.loseContext();
    }
    isStopping = false;
  };

  return { start, stop, isActive: () => isActive };
};

filters.forEach((filterButton) => {
  filterButton.addEventListener("click", () => {
    filters.forEach((button) => button.classList.remove("is-active"));
    filterButton.classList.add("is-active");
    renderProjects(filterButton.dataset.filter);
    if (window.matchMedia("(max-width: 700px)").matches) {
      filtersWrap?.classList.remove("is-open");
      filterToggle?.classList.remove("is-active");
    }
  });
});

filterToggle?.addEventListener("click", () => {
  filtersWrap?.classList.toggle("is-open");
  filterToggle.classList.toggle("is-active");
});

viewButtons.forEach((button) => {
  button.addEventListener("click", () => {
    viewButtons.forEach((item) => item.classList.remove("is-active"));
    button.classList.add("is-active");
    grid.classList.toggle("is-list", button.dataset.view === "list");
    if (button.dataset.view !== "list") {
      hideListPreview();
    }
  });
});

const animateIntro = () => {
  document.body.classList.add("is-intro");
  const lines = intro?.querySelectorAll("[data-scramble]") || [];
  lines.forEach((line, index) => {
    line.dataset.original = line.textContent;
    setTimeout(() => {
      scrambleToText(line, line.dataset.original, { duration: 900 });
    }, index * 140);
  });
};

const hideIntro = () => {
  if (prefersReducedMotion) {
    intro?.remove();
    return;
  }

  setTimeout(() => {
    intro?.classList.add("is-hidden");
    setTimeout(() => {
      document.body.classList.add("is-intro-complete");
      intro?.remove();
      document.body.classList.remove("is-intro");
      triggerGridDrop();
    setTimeout(() => {
      document.body.classList.remove("is-intro-complete");
    }, 1600);
    }, 800);
  }, 1400);
};

const scrambleStaticText = () => {
  const elements = document.querySelectorAll("[data-scramble]");
  let delay = 0;
  elements.forEach((element) => {
    if (element.closest(".work-card") || element.closest(".intro")) return;
    element.dataset.original = element.textContent;
    setTimeout(() => {
      scrambleToText(element, element.dataset.original, { duration: 900 });
    }, delay);
    delay += 70;
  });
};

const setupCursor = () => {
  if (!cursor || prefersReducedMotion) return;
  const move = (event) => {
    cursor.style.left = `${event.clientX}px`;
    cursor.style.top = `${event.clientY}px`;
  };

  window.addEventListener("mousemove", move);
  window.addEventListener("mousedown", () => cursor.classList.add("is-active"));
  window.addEventListener("mouseup", () => cursor.classList.remove("is-active"));
  window.addEventListener("mouseleave", () => cursor.classList.remove("is-active"));
};

const setupUnlockGate = ({ waitForIntro = false } = {}) => {
  const PASSWORD = "EnterM3";
  const STORAGE_KEY = "portfolio_unlocked";
  if (sessionStorage.getItem(STORAGE_KEY) === "true") return;

  const createGate = () => {
    document.body.classList.add("is-locked");
    const gate = document.createElement("div");
    gate.className = "unlock-gate is-visible";
    gate.innerHTML = `
      <form class="unlock-gate__panel" autocomplete="off">
        <div class="unlock-gate__title">Enter password to unlock</div>
        <input
          class="unlock-gate__input"
          type="password"
          name="password"
          placeholder="Password"
          aria-label="Password"
          required
        />
        <button class="unlock-gate__button" type="submit">Unlock</button>
        <div class="unlock-gate__error" aria-live="polite"></div>
      </form>
    `;
    document.body.appendChild(gate);

    const form = gate.querySelector("form");
    const input = gate.querySelector("input");
    const error = gate.querySelector(".unlock-gate__error");

    form.addEventListener("submit", (event) => {
      event.preventDefault();
      if (input.value === PASSWORD) {
        sessionStorage.setItem(STORAGE_KEY, "true");
        document.body.classList.remove("is-locked");
        gate.classList.remove("is-visible");
        gate.remove();
        return;
      }
      gate.classList.add("is-error");
      error.textContent = "Incorrect password.";
      input.select();
      setTimeout(() => gate.classList.remove("is-error"), 350);
    });

    setTimeout(() => input.focus(), 50);
  };

  if (waitForIntro) {
    const observer = new MutationObserver(() => {
      if (!document.body.classList.contains("is-intro")) {
        observer.disconnect();
        createGate();
      }
    });
    observer.observe(document.body, { attributes: true, attributeFilter: ["class"] });
  } else {
    createGate();
  }
};

const setupScrollProgress = () => {
  const bar = document.querySelector(".scroll-progress__bar");
  if (!bar) return;
  const update = () => {
    const doc = document.documentElement;
    const scrollTop = window.scrollY || doc.scrollTop;
    const max = doc.scrollHeight - window.innerHeight;
    const progress = max > 0 ? scrollTop / max : 0;
    bar.style.transform = `scaleY(${progress})`;
  };
  update();
  window.addEventListener("scroll", update, { passive: true });
  window.addEventListener("resize", update);
};

const setupBackToTop = () => {
  const button = document.querySelector(".back-to-top");
  if (!button) return;
  const update = () => {
    const y =
      window.pageYOffset ||
      document.documentElement.scrollTop ||
      document.body.scrollTop ||
      0;
    button.classList.toggle("is-visible", y > 360);
  };
  update();
  window.addEventListener("scroll", update, { passive: true });
  button.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
};

const setupHoverScramble = () => {
  const targets = document.querySelectorAll("a[data-scramble]");
  targets.forEach((target) => {
    if (target.closest(".work-card")) return;
    target.dataset.original = target.dataset.original || target.textContent;
    target.addEventListener("mouseenter", () => startScrambleLoop(target, 400));
    target.addEventListener("mouseleave", () => {
      stopScrambleLoop(target);
      scrambleToText(target, target.dataset.original, { duration: 200 });
    });
  });
};

const setupRoleRotation = () => {
  const role = document.querySelector(".brand__role");
  if (!role) return;
  const roleData = window.SITE_DATA?.person?.rotatingRole;
  const phrases =
    roleData?.phrases || [
      { text: "Product Designer", duration: 3600 },
      { text: "Pixel Pusher", duration: 2400 },
      { text: "Making It Pop", duration: 3200 },
      { text: "Design Storyteller", duration: 4200 },
    ];
  const colors =
    roleData?.colors || ["#ff3b30", "#ff9500", "#34c759", "#5e5ce6", "#bf5af2"];
  let index = 0;
  let lastColor = "";
  let rotationTimer = null;

  const pickColor = () => {
    const options = colors.filter((color) => color !== lastColor);
    const nextColor = options[Math.floor(Math.random() * options.length)];
    lastColor = nextColor;
    return nextColor;
  };

  const scheduleNext = () => {
    if (rotationTimer) window.clearTimeout(rotationTimer);
    const current = phrases[index];
    rotationTimer = window.setTimeout(() => {
      index = (index + 1) % phrases.length;
      const next = phrases[index];
      role.style.color = pickColor();
      role.dataset.original = next.text;
      scrambleToText(role, next.text, { duration: 600, interval: 12 });
      scheduleNext();
    }, current.duration);
  };

  role.dataset.original = phrases[0].text;
  role.style.color = pickColor();
  scrambleToText(role, phrases[0].text, { duration: 600, interval: 12 });
  scheduleNext();
};

const setupHeaderScroll = () => {
  const header = document.querySelector(".site-header");
  if (!header) return;
  let lastY = window.scrollY;
  let isHidden = false;

  window.addEventListener("scroll", () => {
    const currentY = window.scrollY;
    const delta = currentY - lastY;
    if (currentY < 20) {
      isHidden = false;
      header.classList.remove("is-hidden");
    } else if (delta > 8 && currentY > 260) {
      isHidden = true;
      header.classList.add("is-hidden");
    } else if (delta < -8) {
      isHidden = false;
      header.classList.remove("is-hidden");
    }
    lastY = currentY;
  });

  window.addEventListener("mousemove", (event) => {
    if (event.clientY < 80 && isHidden) {
      isHidden = false;
      header.classList.remove("is-hidden");
    }
  });
};

const setupMobileMenu = () => {
  const toggle = document.querySelector(".menu-toggle");
  const actions = document.querySelector(".site-actions");
  const closeButton = document.querySelector(".drawer-close");
  const backdrop = document.querySelector(".drawer-backdrop");
  const links = document.querySelectorAll(".site-actions a");
  if (!toggle || !actions) return;
  toggle.addEventListener("click", () => {
    actions.classList.toggle("is-open");
    actions.classList.remove("is-closing");
    backdrop?.classList.toggle("is-active", actions.classList.contains("is-open"));
    document.body.classList.toggle(
      "is-drawer-open",
      actions.classList.contains("is-open")
    );
  });
  const closeDrawer = () => {
    actions.classList.add("is-closing");
    actions.classList.remove("is-open");
    backdrop?.classList.remove("is-active");
    document.body.classList.remove("is-drawer-open");
    setTimeout(() => actions.classList.remove("is-closing"), 350);
  };
  closeButton?.addEventListener("click", closeDrawer);
  backdrop?.addEventListener("click", closeDrawer);
  links.forEach((link) => {
    link.addEventListener("click", () => {
      closeDrawer();
    });
  });
};

const setupLanguageSwitch = () => {
  const buttons = document.querySelectorAll(".lang-switch__btn");
  buttons.forEach((button) => {
    button.addEventListener("click", () => {
      const lang = button.dataset.lang;
      if (!translations[lang]) return;
      currentLang = lang;
      document.documentElement.lang = lang;
      buttons.forEach((btn) => btn.classList.remove("is-active"));
      button.classList.add("is-active");
      applyLanguage();
    });
  });
};

const applyLanguage = () => {
  const dictionary = translations[currentLang];
  const elements = document.querySelectorAll("[data-i18n]");
  elements.forEach((element) => {
    const key = element.dataset.i18n;
    if (!dictionary[key]) return;
    element.textContent = dictionary[key];
  });

  const attrTargets = document.querySelectorAll("[data-i18n-attr]");
  attrTargets.forEach((element) => {
    const key = element.dataset.i18n;
    const attr = element.dataset.i18nAttr;
    if (!dictionary[key] || !attr) return;
    element.setAttribute(attr, dictionary[key]);
  });

  applySiteData(currentLang);
  setupFooterStatusRotation();

  const scrambleTargets = document.querySelectorAll("[data-scramble]");
  scrambleTargets.forEach((target) => {
    target.dataset.original = target.textContent;
  });
};

const applySiteData = (lang = "en") => {
  const site = window.SITE_DATA;
  if (!site) return;

  const person = site.person;
  const nameEl = document.querySelector('[data-site="name"]');
  if (person?.name && nameEl) {
    nameEl.textContent = person.name;
  }

  const role = person?.role?.[lang];
  const roleEl = document.querySelector('[data-site="role"]');
  if (role && roleEl) {
    roleEl.textContent = role;
  }

  const title = site.pageTitles?.home;
  if (title) {
    document.title = title;
  }

  const introLines = site.intro?.lines?.[lang];
  if (introLines?.length) {
    const introWrap = document.querySelector(".intro");
    if (introWrap && site.intro?.align) {
      introWrap.style.textAlign = site.intro.align;
    }
    const introLine1 = document.querySelector('[data-site="intro-line-1"]');
    const introLine2 = document.querySelector('[data-site="intro-line-2"]');
    const introSize = site.intro?.fontSize;
    if (introLine1) {
      introLine1.textContent = introLines[0] || "";
      if (introSize) introLine1.style.fontSize = introSize;
    }
    if (introLine2) {
      introLine2.textContent = introLines[1] || "";
      if (introSize) introLine2.style.fontSize = introSize;
    }
  }

  const aboutTitle = site.about?.title?.[lang];
  const aboutTitleEl = document.querySelector('[data-site="about-title"]');
  if (aboutTitle && aboutTitleEl) {
    aboutTitleEl.textContent = aboutTitle;
  }

  const aboutBody = site.about?.body?.[lang];
  const aboutBodyEl = document.querySelector('[data-site="about-body"]');
  if (aboutBody && aboutBodyEl) {
    aboutBodyEl.textContent = aboutBody;
  }

  const footer = site.footer;
  const footerLine = footer?.line?.[lang];
  if (footerLine) {
    document.querySelectorAll('[data-i18n="footer_line"]').forEach((element) => {
      element.textContent = footerLine;
    });
  }

  const statusList = footer?.status?.[lang] || footer?.status?.en;
  const statusItem = Array.isArray(statusList) ? statusList[0] : null;
  const statusEl = document.querySelector('[data-site="status"]');
  if (statusItem?.text && statusEl) {
    statusEl.textContent = statusItem.text;
  }

  const email = footer?.email;
  const emailEl = document.querySelector('[data-site="email"]');
  if (email && emailEl) {
    emailEl.textContent = email;
    emailEl.setAttribute("href", `mailto:${email}`);
  }

  const copyright = footer?.copyright;
  const copyrightEl = document.querySelector('[data-site="copyright"]');
  if (copyright && copyrightEl) {
    copyrightEl.textContent = copyright;
  }
};

const setupFooterStatusRotation = () => {
  const statusEl = document.querySelector('[data-site="status"]');
  const statusData = window.SITE_DATA?.footer?.status;
  if (!statusEl || !statusData) return;
  const raw = statusData[currentLang] || statusData.en || [];
  const phrases = raw.map((item) =>
    typeof item === "string" ? { text: item, duration: 3600 } : item
  );
  if (!phrases.length) return;
  if (footerStatusTimer) window.clearTimeout(footerStatusTimer);
  let index = 0;

  const scheduleNext = () => {
    const current = phrases[index];
    footerStatusTimer = window.setTimeout(() => {
      index = (index + 1) % phrases.length;
      const next = phrases[index];
      statusEl.dataset.original = next.text;
      scrambleToText(statusEl, next.text, { duration: 600, interval: 12 });
      scheduleNext();
    }, current.duration || 3600);
  };

  statusEl.dataset.original = phrases[0].text;
  scrambleToText(statusEl, phrases[0].text, { duration: 600, interval: 12 });
  scheduleNext();
};


const openProject = (project) => {
  const slugValue = project.slug || project.title.toLowerCase().replace(/\s+/g, "-");
  const slug = encodeURIComponent(slugValue);
  window.location.href = `project.html?project=${slug}`;
};

const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
if (isSafari) {
  document.documentElement.classList.add("is-safari");
}


renderProjects("all");
applyLanguage();
animateIntro();
scrambleStaticText();
hideIntro();
setupCursor();
setupHoverScramble();
setupHeaderScroll();
setupLanguageSwitch();
setupMobileMenu();
setupRoleRotation();
setupFooterStatusRotation();
setupScrollProgress();
setupPageTransitions();
setupBackToTop();
setupUnlockGate({ waitForIntro: true });

grid.addEventListener("click", (event) => {
  const card = event.target.closest(".work-card");
  if (!card) return;
  event.preventDefault();
  const index = Array.from(grid.children).indexOf(card);
  const activeFilter = document.querySelector(".filter.is-active")?.dataset.filter;
  const filtered = projects.filter((project) =>
    activeFilter === "all" ? true : project.tags.includes(activeFilter)
  );
  const project = filtered[index];
  if (project) openProject(project);
});
